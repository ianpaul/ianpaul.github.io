---
layout: post
title: Learning through iterative goals
tags: [programming, python, rust]
image: path.jpg
---

Learning my first programming language was not easy, and it took years before I could finally say I actually knew how to use a programming language. It took so long because I was stuck with this idea of how it was supposed to go. I thought you learned the language, and then it was off to building whatever you wanted. Nope. 

It's the application of knowledge that makes programming difficult. I'd tried learning Objective-C, JavaScript, and a few other things, and I did well enough with the assignments in the book or the course. But when it came time to do something on my own like an app or a website I was completely lost. The jobs I set out for myself were just too big, and I couldn't take two steps without consulting a book or website. Eventually, I'd just give up.

My attempt at Python was different. I started by contributing to [Flashbake](https://github.com/cmdln/flashbake/). I really liked the idea of the project, I used it myself, and I wanted to help out if I could. The fact that it was written in Python was really a secondary concern. It was all about doing something for this project that I cared about.

So I started small going through the issues and finding easy fixes that I thought I could do. I didn't even really know much about Python at the time. I just followed the patterns in existing code, adapted them, consulted with Stack Overflow, and figured things out. 

It was a slow, iterative process and something I couldn't have done were it not for my previous false starts with other languages. Those early experiences gave me enough understanding of syntax to figure out what was going on--it also helped that Python is very readable. 

I learned more and more and it wasn't long before I was creating my own Flashbake plugins. Somewhere along the way I also went through the first half of *Python Crash Course, 2nd Edition* by Eric Matthes to get a solid grounding in the basics. 

Then it was on to porting Flashbake to Python 3, which was a much bigger (and more intimidating) job. At first I thought I'd study up on the differences between Python 2 and 3, and then just read through the code going, "ah ha! Of course, that requires a different keyword now," or whatever. That was a fantasy.

So I did what I expect most people do: brute force the thing. I'd try to install the Python 2 version in Python 3. Then read the error messages about why the install failed, fix those problems, and start again. 

Then once I was able to install it without errors, I'd run it, and of course it wouldn't work. Again I'd read the errors, fix them, and try again. Sometimes there were no error messages at all just failures or unexpected behavior. This was another slow, iterative process, but after two weeks of late nights [I had the whole thing working](https://github.com/cmdln/flashbake/pull/40/commits). 

I learned a ton during that time, and it was in many ways the perfect intermediate project. I didn't have to invent anything from whole cloth, but I did have to understand how to adapt a lot of code.

Since then I've continued to build on what I know to maintain and improve Flashbake. I also wrote scripts that make my day-to-day life easier, built a few math games to help my kids, and did a good amount of work on data analysis with Jupyter Notebooks, SQL, and CSV files. 

It's been a great experience, and Python really is a wonderful language to start with. But the key for me wasn't so much the language but the fact that I had small, achievable goals with practical value.

Now, I'm on to learning Rust. This time I'm learning the basics of the language and planning small, achievable goals that build on what I already know. 



